import { WebSocketServer, WebSocket } from "ws";
import type { Server } from "http";

interface Player {
  id: string;
  ws: WebSocket;
  username: string;
  elo: number;
  language: string;
  difficulty: string;
  topic?: string;
}

interface Match {
  id: string;
  player1: Player;
  player2: Player;
  topic: string;
  vocabulary: any[];
}

class MatchmakingQueue {
  private queue: Player[] = [];
  private matches: Map<string, Match> = new Map();
  private playerSockets: Map<WebSocket, Player> = new Map();
  
  addToQueue(player: Player) {
    this.queue.push(player);
    this.playerSockets.set(player.ws, player);
    console.log(`Player ${player.username} (${player.elo} Elo) joined queue. Queue size: ${this.queue.length}`);
    
    // Try to find a match immediately
    this.tryMatch(player);
  }

  removeFromQueue(ws: WebSocket) {
    const player = this.playerSockets.get(ws);
    if (player) {
      this.queue = this.queue.filter(p => p.id !== player.id);
      this.playerSockets.delete(ws);
      console.log(`Player ${player.username} removed from queue. Queue size: ${this.queue.length}`);
    }
  }

  private tryMatch(newPlayer: Player) {
    // Find an opponent with similar Elo (+/- 200) and same language/difficulty
    const potentialOpponents = this.queue.filter(p => 
      p.id !== newPlayer.id &&
      p.language === newPlayer.language &&
      p.difficulty === newPlayer.difficulty &&
      Math.abs(p.elo - newPlayer.elo) <= 200
    );

    if (potentialOpponents.length > 0) {
      // Find the closest Elo match
      const opponent = potentialOpponents.reduce((closest, current) => {
        const closestDiff = Math.abs(closest.elo - newPlayer.elo);
        const currentDiff = Math.abs(current.elo - newPlayer.elo);
        return currentDiff < closestDiff ? current : closest;
      });

      // Create a match
      this.createMatch(newPlayer, opponent);
    } else {
      // No match found - wait 5 seconds then assign AI bot
      setTimeout(() => {
        // Check if player is still in queue (not matched with someone else)
        if (this.queue.some(p => p.id === newPlayer.id)) {
          this.assignAIBot(newPlayer);
        }
      }, 5000); // 5 second wait time
    }
  }

  private createMatch(player1: Player, player2: Player) {
    // Remove both players from queue
    this.queue = this.queue.filter(p => p.id !== player1.id && p.id !== player2.id);

    // Randomly select topic (or use player's selected topic for practice mode)
    const topic = player1.topic || this.getRandomTopic();

    const matchId = `${player1.id}-${player2.id}-${Date.now()}`;
    const match: Match = {
      id: matchId,
      player1,
      player2,
      topic,
      vocabulary: [], // Will be generated by frontend
    };

    this.matches.set(matchId, match);

    // Notify both players
    player1.ws.send(JSON.stringify({
      type: 'match_found',
      matchId,
      opponent: {
        username: player2.username,
        elo: player2.elo,
      },
      topic,
      language: player1.language,
      difficulty: player1.difficulty,
      isAI: false,
    }));

    player2.ws.send(JSON.stringify({
      type: 'match_found',
      matchId,
      opponent: {
        username: player1.username,
        elo: player1.elo,
      },
      topic,
      language: player2.language,
      difficulty: player2.difficulty,
      isAI: false,
    }));

    console.log(`Match created: ${player1.username} (${player1.elo}) vs ${player2.username} (${player2.elo})`);
  }

  private assignAIBot(player: Player) {
    // Remove from queue
    this.queue = this.queue.filter(p => p.id !== player.id);

    // Use player's topic or random
    const topic = player.topic || this.getRandomTopic();

    // Generate random bot name
    const botName = this.getRandomBotName();

    // Notify player - they'll play against AI
    player.ws.send(JSON.stringify({
      type: 'match_found',
      matchId: `ai-${player.id}-${Date.now()}`,
      opponent: {
        username: botName,
        elo: player.elo, // AI bot matches player's Elo for balanced difficulty
      },
      topic,
      language: player.language,
      difficulty: player.difficulty,
      isAI: true,
    }));

    console.log(`AI bot (${botName}) assigned to ${player.username} (${player.elo})`);
  }

  private getRandomTopic(): string {
    const topics = [
      'Travel', 'Food & Dining', 'Business & Work', 'Family & Relationships',
      'Technology', 'Health & Fitness', 'Education', 'Entertainment',
      'Nature & Environment', 'Shopping', 'Sports', 'Weather',
      'Social Events', 'Music & Arts', 'Hobbies & Leisure', 'Home & Daily Life',
      'Transportation & Commute', 'Animals & Pets', 'Clothing & Fashion',
      'Holidays & Celebrations', 'Emotions & Feelings'
    ];
    return topics[Math.floor(Math.random() * topics.length)];
  }

  private getRandomBotName(): string {
    const botNames = [
      'Emma Chen', 'Lucas Rodriguez', 'Sofia Martinez', 'Wei Zhang',
      'Aisha Patel', 'Nikolai Petrov', 'Isabella Rossi', 'Kenji Tanaka',
      'Leila Hassan', 'Marcus Johnson', 'Yuki Yamamoto', 'Fatima Al-Rashid',
      'Diego Silva', 'Amara Okafor', 'Sven Andersson', 'Priya Sharma',
      'Alexandre Dubois', 'Maya Cohen', 'Rashid Ahmed', 'Nina Kowalski',
      'Carlos Mendoza', 'Ingrid Larsson', 'Omar Hassan', 'Valentina Romano',
      'Jin Park', 'Aaliyah Thompson', 'Anton Volkov', 'Zara Ibrahim'
    ];
    return botNames[Math.floor(Math.random() * botNames.length)];
  }
}

export function setupMatchmaking(httpServer: Server) {
  const wss = new WebSocketServer({ 
    server: httpServer,
    path: '/matchmaking'
  });

  const queue = new MatchmakingQueue();

  wss.on('connection', (ws: WebSocket) => {
    console.log('New WebSocket connection');

    ws.on('message', (data: Buffer) => {
      try {
        const message = JSON.parse(data.toString());

        if (message.type === 'join_queue') {
          const player: Player = {
            id: message.playerId || `player-${Date.now()}`,
            ws,
            username: message.username || 'Guest',
            elo: message.elo || 1000,
            language: message.language,
            difficulty: message.difficulty,
            topic: message.topic, // Optional - only for practice mode
          };
          queue.addToQueue(player);
        }

        if (message.type === 'leave_queue') {
          queue.removeFromQueue(ws);
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    });

    ws.on('close', () => {
      // Clean up player from queue when connection closes
      queue.removeFromQueue(ws);
      console.log('WebSocket connection closed - player removed from queue');
    });

    ws.on('error', (error) => {
      console.error('WebSocket error:', error);
      // Also remove from queue on error
      queue.removeFromQueue(ws);
    });
  });

  console.log('WebSocket matchmaking server initialized on /matchmaking');

  return wss;
}
